---
title: Leetcode题解-缺失数字&寻找重复数&缺失的第一个正数
typora-root-url: ../../source/
date: 2019-10-31 20:09:29
comments: true
tags:
---

Q41 缺失的第一个正数 https://leetcode-cn.com/problems/first-missing-positive/ 

Q287 寻找重复数  https://leetcode-cn.com/problems/find-the-duplicate-number/ 

Q268 缺失数字  https://leetcode-cn.com/problems/missing-number/ 

<!--more-->

# 缺失的第一个正数

## 题目

 给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 

示例 1:

> 输入: [1,2,0]
> 输出: 3

示例 2:

> 输入: [3,4,-1,1]
> 输出: 2

示例 3:

> 输入: [7,8,9,11,12]
> 输出: 1

 **算法的时间复杂度应为O(*n*)，并且只能使用常数级别的空间。** 

```Java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int N = nums.length;
        for(int i = 0; i < N;){
           	int t = nums[i];
            if(t > 0 && t <= N && t != i+1 && nums[t-1] != t){
                swap(nums, i, nums[i]-1);
            }else{
                i++;
            }
        }
        for(int i = 0;i < N;i++){
            if(nums[i] != i+1){
               return i+1;
            }
        }
        return N+1;
    }

    private void swap(int[] nums, int i, int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```

# 寻找重复数

## 题目

给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

示例 1:

> 输入: [1,3,4,2,2]
> 输出: 2

示例 2:

> 输入: [3,1,3,4,2]
> 输出: 3

说明：

> 不能更改原数组（假设数组是只读的）。
> 只能使用额外的 O(1) 的空间。
> 时间复杂度小于 O(n2) 。
> 数组中只有一个重复的数字，但它可能不止重复出现一次。



```java
//不考虑【不能更改原数组】的限制
class Solution {
    public int findDuplicate(int[] nums) {
        int n = nums.length;
        //put i in nums[i-1]
        for(int i = 0; i < n; i++){
            while(nums[i]-1 != i){
                if(!swap(nums, i, nums[i]-1)){
                    return nums[i];
                }
            }
        }
        
        return -1;
    }

    private boolean swap(int[] nums, int i, int j){
        if(nums[i]==nums[j]){
            return false;
        }
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
        return true;
    }
}
```

