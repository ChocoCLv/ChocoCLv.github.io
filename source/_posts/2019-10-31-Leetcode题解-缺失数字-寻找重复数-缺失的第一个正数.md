---
title: Leetcode题解-缺失数字&寻找重复数&缺失的第一个正数
typora-root-url: ../../source/
date: 2019-10-31 20:09:29
comments: true
tags:
- 算法
- 鸽笼定理
- 位运算
---

Q41 缺失的第一个正数 https://leetcode-cn.com/problems/first-missing-positive/ 

Q287 寻找重复数  https://leetcode-cn.com/problems/find-the-duplicate-number/ 

Q268 缺失数字  https://leetcode-cn.com/problems/missing-number/ 

<!--more-->

# 缺失的第一个正数

## 题目

 给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 

示例 1:

> 输入: [1,2,0]
> 输出: 3

示例 2:

> 输入: [3,4,-1,1]
> 输出: 2

示例 3:

> 输入: [7,8,9,11,12]
> 输出: 1

 **算法的时间复杂度应为O(*n*)，并且只能使用常数级别的空间。** 

## 分析

找到第一个缺失的正整数，即从1开始寻找，直到i不在数组中。

遍历数组，如果nums[i]是合法的，则将nums[i]-1放到i上，即nums[1]=2,nums[0]=1。
$$
nums[i] \in [1,nums.length]
$$
以示例2为例：

![1572594110000](/imgs/1572594110000.png)

遍历完成后

![1572594259894](/imgs/1572594259894.png)

再次遍历，遇到的第一个不合法的位置，对应的value即为第一个缺失的正整数。

```Java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int N = nums.length;
        for(int i = 0; i < N;){
           	int t = nums[i];
            if(t > 0 && t <= N && t != i+1 && nums[t-1] != t){
                swap(nums, i, nums[i]-1);
            }else{
                i++;
            }
        }
        for(int i = 0;i < N;i++){
            if(nums[i] != i+1){
               return i+1;
            }
        }
        return N+1;
    }

    private void swap(int[] nums, int i, int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```

# 寻找重复数

## 题目

给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

示例 1:

> 输入: [1,3,4,2,2]
> 输出: 2

示例 2:

> 输入: [3,1,3,4,2]
> 输出: 3

说明：

> 不能更改原数组（假设数组是只读的）。
> 只能使用额外的 O(1) 的空间。
> 时间复杂度小于 O(n2) 。
> 数组中只有一个重复的数字，但它可能不止重复出现一次。

## 分析

### 鸽笼

思路与上一题类似，使得nums[i]-1=i。数组中所有数字都是合法的，但是存在重复数字，所以在交换前判断是否重复。这样就能找到重复数字。

```java
// 不满足【不能更改原数组】的限制
class Solution {
    public int findDuplicate(int[] nums) {
        int n = nums.length;
        //put i-1 in nums[i]
        for(int i = 0; i < n; i++){
            while(nums[i]-1 != i){
                if(!swap(nums, i, nums[i]-1)){
                    return nums[i];
                }
            }
        }
        
        return -1;
    }

    private boolean swap(int[] nums, int i, int j){
        if(nums[i]==nums[j]){
            return false;
        }
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
        return true;
    }
}
```

### HashSet

直接使用Set判断是否重复。

### 排序

排序后判断相邻两个数字是否相等。

### 链表找环

![1572594944006](/imgs/1572594944006.png)

在第一种解法中实际上隐含了将i与nums[i]对应起来，对于一个单元包括Index和value，value可以对应到链表的next。
$$
nums[i] \in [1, n-1]
$$
![1572595448935](/imgs/1572595448935.png)

![1572595565801](/imgs/1572595565801.png)

题目中说明了只有一个数字重复，则只有一个点的入度大于1，且这个点即为重复数字。
$$
d[i]=
\begin{cases}
  0  \\\\
  1 \\\\
 k, & k>1,k为重复次数
\end{cases}
$$

转化成在链表中找环入口的问题，快慢指针解决即可。

这种解法可满足题目的时间复杂度和空间复杂度要求。

# 缺失数字

## 题目

给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。

示例 1:

> 输入: [3,0,1]
> 输出: 2

示例 2:

> 输入: [9,6,4,2,3,5,7,0,1]
> 输出: 8

## 分析

### 鸽笼

同样的思路，只不过nums[i]从0开始取值，可使用单独的变量存储最大值，nums[i]==i。

```java
class Solution {
    public int missingNumber(int[] nums) {
        int MAX = nums.length;

        //0-n-1, n(max_holder)
        for(int i = 0; i < MAX;){
            int t = nums[i];
            if(t == MAX){
                i++;
                continue;
            }
            if(t != i){
                swap(nums, i, t);
            }else{
                i++;
            }
        }

        for(int i = 0; i < MAX; i++){
            if(nums[i] != i){
                return i;
            }
        }
        return MAX;
        
    }

    private void swap(int[] nums, int i, int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```

### 位运算

题目标签提示可用位运算解决。

数组长度为n，nums[i]取值范围为[0,n]，并且没有重复数字，只有一个数字没出现。

那么连续异或[0,n]以及nums[i]，只有一个数字出现一次，其他都出现两次。最后的结果就是缺失的数字

```java
class Solution {
    public int missingNumber(int[] nums) {
        int result = 0;
        for(int i = 0;i < nums.length; i++){
            result ^= i;
            result ^= nums[i];
        }
        return result^nums.length;
    }
}
```

