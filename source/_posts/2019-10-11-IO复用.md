---
title: IO复用
typora-root-url: ../../source/
date: 2019-10-11 13:37:10
tags:
- unix
- 网络编程
- IO复用
- select
- poll
- epoll
---

内核一旦发现进程指定的一个或多个I/O条件就绪，它就通知进程。这种能力称为I/O复用。

<!--more-->

# IO模型

Unix下5种IO模型：

|                         | 介绍                                                         | 特点                                        |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------- |
| 阻塞式I/O               |                                                              |                                             |
| 非阻塞式I/O             | 非阻塞+轮询                                                  | 耗费大量CPU时间                             |
| I/O复用（select和poll） | select/poll+I/O                                              | 可以同时处理多个描述符                      |
| 信号驱动式I/O           | 内核在就绪时发送SIGIO信号                                    | 就续前进程不被阻塞；通知何时启动一个I/O操作 |
| 异步I/O                 | 告知内核启动某个操作，在整个操作（包括将数据从内核复制到用户空间）完成后通知 | 通知何时I/O操作完成                         |

前四种模型均为同步I/O。

同步I/O：导致请求进程阻塞，直到I/O操作完成

异步I/O：不导致请求进程阻塞。

![1570773791564](/imgs/1570773791564.png)

# select函数

该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。

```c
#include <sys/select.h>
#include <sys/time.h>

int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);
//若有就绪描述符则返回数目，超时返回0，出错返回-1
```

当三个set均为空指针时，可以用作精度为us的定时器

# poll函数

poll的功能与select类似

```c
#include <poll.h>

//timeout单位：ms
int poll(struct pollfd *fdarray, unsigned long nfds, int timeout);
//若有就绪描述符则返回数目，超时返回0，出错返回-1

struct pollfd{
    int fd;
    short events;//该描述符上感兴趣的事件
    short revents;//该描述符上发生的事件
}
```

# epoll

不同于select和poll，epoll由三部分组成。

## 函数原型

```c
/**
 * 创建epoll句柄
 * size：最大socket fd数
 */
int epoll_create(int size);  


/**
 * 该函数用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，删除事件。
 * epfd：由 epoll_create 生成的epoll专用的文件描述符；
 * op：要进行的操作例如注册事件，可能的取值EPOLL_CTL_ADD 注册、EPOLL_CTL_MOD 修 改、EPOLL_CTL_DEL 删除
 * fd：关联的文件描述符；
 * event：指向epoll_event的指针；
 */
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);  


/**
 * 等待事件触发，当超过timeout还没有事件触发时，就超时。
 * epfd:由epoll_create 生成的epoll专用的文件描述符；
 * epoll_event:用于回传代处理事件的数组；
 * maxevents:每次能处理的事件数；
 * timeout:等待I/O事件发生的超时值；-1相当于阻塞，0相当于非阻塞。一般用-1即可
 */
int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);  

struct epoll_event
{
  uint32_t events;   /* Epoll events */
  epoll_data_t data;    /* User data variable */
} __attribute__ ((__packed__));

typedef union epoll_data
{
  void *ptr;
  int fd;
  uint32_t u32;
  uint64_t u64;
} epoll_data_t;
```

> 对于epoll_wait
>
> 等侍注册在epfd上的socket fd的事件的发生，如果发生则将发生的sokct fd和事件类型放入到events数组中。
> 并 且将注册在epfd上的socket fd的事件类型给清空，所以如果下一个循环你还要关注这个socket fd的话，则**需要用epoll_ctl(epfd,EPOLL_CTL_MOD,listenfd,&ev)来重新设置socket fd的事件类型**。这时不用EPOLL_CTL_ADD,因为socket fd并未清空，只是事件类型清空。

## 原理

调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个rdllist双向链表，用于存储准备就绪的事件，**当epoll_wait调用时，仅仅观察这个rdllist双向链表里有没有数据即可**。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。

所有添加到epoll中的事件都会与设备(如网卡)驱动程序**建立回调关系**，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做**ep_poll_callback**，它会把这样的事件放到上面的rdllist双向链表中。

## 触发方式

LT（水平触发）模式下，只要这个文件描述符还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作；

ET（边缘触发）模式下，在它检测到有 I/O 事件时，通过 epoll_wait 调用会得到有事件通知的文件描述符，对于每一个被通知的文件描述符，如可读，则必须将该文件描述符一直读到空，让 errno 返回 EAGAIN 为止，否则下次的 epoll_wait 不会返回余下的数据，会丢掉事件。如果ET模式不是非阻塞的，那这个一直读或一直写势必会在最后一次阻塞。

ET的优点：

如果采用EPOLLLT模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率.。而采用EPOLLET这种边缘触发模式的话，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。

# select、poll、epoll对比

三种都是同步I/O

(1)select==>时间复杂度O(n)

它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以**select具有O(n)的无差别轮询复杂度**，同时处理的流越多，无差别轮询时间就越长。

(2)poll==>时间复杂度O(n)

poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， **但是它没有最大连接数的限制**，原因是它是基于链表来存储的.

(3)epoll==>时间复杂度O(1)

**epoll可以理解为event poll**，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是**事件驱动（每个事件关联上fd）**的，此时我们对这些流的操作都是有意义的。**（复杂度降低到了O(1)）**

## select的缺点

（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大

（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大

（3）select支持的文件描述符数量太小了，默认是1024

## poll的缺点

除了没有最大连接数的限制，其他与select相同。

## epoll

​		epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。

　　对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。

　　对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。

　　对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。

# 参考

https://blog.csdn.net/daaikuaichuan/article/details/83862311

https://www.cnblogs.com/aspirant/p/9166944.html

《UNIX网络编程》I/O复用：select和poll函数