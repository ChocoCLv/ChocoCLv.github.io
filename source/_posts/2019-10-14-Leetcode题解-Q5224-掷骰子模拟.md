---
title: Leetcode题解-Q5224-掷骰子模拟
typora-root-url: ../../source/
date: 2019-10-14 16:23:16
mathjax: true
tags:
- leetcode
- 动态规划
---

链接：https://leetcode-cn.com/problems/dice-roll-simulation

<!--more-->

# 掷骰子模拟

## 题目

有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。

不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字 i 的次数不能超过 rollMax[i]（i 从 1 开始编号）。

现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。

假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。 

示例 1：

> 输入：n = 2, rollMax = [1,1,2,2,2,3]
> 输出：34
> 解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。

示例 2：

> 输入：n = 2, rollMax = [1,1,1,1,1,1]
> 输出：30

示例 3：

> 输入：n = 3, rollMax = [1,1,1,2,2,3]
> 输出：181


提示：

> 1 <= n <= 5000
> rollMax.length == 6
> 1 <= rollMax[i] <= 15

## 分析 

典型的动态规划问题，OPT(n)与OPT(n-1)有关，由于题目要求连续掷出数字i的次数不能超过rollMax[i]，所以第n次可以掷出的数字与第n-1次掷出的数字以及其连续出现的次数有关。使用dp\[i\]\[j\]\[k\]保存状态。

即dp\[i\]\[j\]\[k\]代表第i次掷出数字j，并且数字j在末尾已经连续出现了k次，这种约束下的组合数。

状态转移：
$$
dp[i][j][k]=
\begin{cases}
  1, & i=1 \\\\
  dp[i-1][j][k-1],&k>1 \\\\
 \sum_{z=1,z\not=j}^6\sum_{c=1}^{rollMax[z]} dp[i-1][z][c], & k=1
\end{cases}
$$
$$
i\in[1,n],j\in[1,6],k\in[1,rollMax[j]]
$$

当k=1时，说明n-1掷出的不是j；当k>1时，说明n-1掷出j，且前面连续出现了k-1次。



## 代码

```java
public class DieSimulator {
    static class Solution {
        public int dieSimulator(int n, int[] rollMax) {
            //dp[i][j][k]表示在第i次掷骰子，出现的点数为j，并且点数j在前面连续出现了k次的可能情况数量
            long[][][] dp = new long[5001][7][16];
            int mod = 1000000007;
            for (int i = 1; i <= n; i++) {
                if (i == 1) {
                    for (int j = 1; j <= 6; j++) {
                        dp[1][j][1] = 1;
                    }
                    continue;
                }
                for (int j = 1; j <= 6; j++) {
                    for (int k = 1; k <= rollMax[j - 1]; k++) {
                        if (k == 1) {
                            for (int z = 1; z <= 6; z++) {
                                if (z != j) {
                                    for (int c = 1; c <= rollMax[z - 1]; c++) {
                                        dp[i][j][k] = (dp[i - 1][z][c] + dp[i][j][k]) % mod;
                                    }
                                }
                            }
                        } else {
                            dp[i][j][k] = dp[i - 1][j][k - 1];
                        }
                    }
                }
            }

            long res = 0;
            for (int j = 1; j <= 6; j++) {
                for (int k = 1; k <= rollMax[j - 1]; k++) {
                    res = (res + dp[n][j][k]) % mod;
                }
            }

            return (int) res;
        }
    }
}
```

