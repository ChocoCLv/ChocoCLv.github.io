---
title: 'Redis:持久化'
typora-root-url: ../../source/
date: 2019-09-16 00:04:06
tags:
- redis
- 持久化
---

Redis支持RDB和AOF持久化机制，注意持久化机制并不完全等同于主从复制原理。RDB将内存数据以文件保存在本地，会对数据进行压缩，适合备份、全量复制等场景。AOF以独立日志的方式记录每次写命令，类似mysql的binlog。解决了RDB的实时性问题。



<!--more-->

# RDB

## 触发机制

将当前进程数据生成快照保存到硬盘。RDB持久化可以手动触发也可以自动触发。

| 触发机制 | 触发方式                                   |      |
| -------- | ------------------------------------------ | ---- |
| 手动触发 | save：阻塞当前服务器直到持久化完成，以废弃 |      |
|          | bgsave：fork子进程，阻塞只发生在fork阶段   |      |
| 自动触发 | save m n：m秒内达到n次修改时触发           |      |
|          | 从节点执行全量复制，主节点自动bgsave       |      |
|          | debug reload                               |      |
|          | shutdown时如果没有开启AOF则bgsave          |      |

## bgsave流程

<img src="/imgs/1568637625579.png" alt="1568637625579" style="zoom:50%;" />

## RDB文件的处理

- 默认采用LZF算法进行压缩，压缩后的文件大小远远小于内存大小，默认开启
- 加载损坏的RDB文件时拒绝启动

## RDB的优缺点

优点：

- 文件紧凑压缩，适合备份、全量复制
- 数据恢复快

缺点：

- 无法实时持久化
- 存在多个版本的RDB文件格式

# AOF

以独立日志的方式记录每次写命令，类似mysql的binlog。解决了RDB的实时性问题。

## 工作流程

<img src="/imgs/1568721676828.png" alt="1568721676828" style="zoom:50%;" />

- AOF并不是直接将命令写入磁盘，而是先写入缓冲，通过提供不同的刷盘策略在性能和安全性方面做出平衡。
- 刷盘策略有：实时刷盘；每秒刷盘；操作系统负责刷盘（存在page cache）
- 随着AOF文件越来越大，不仅占空间，而且数据恢复时间也会很长，所以需要定期重写AOF，对AOF文件进行压缩。（删除无效命令、合并多条命令）。
- 重启恢复数据时优先使用aof

## AOF重写流程

1. fork子进程对AOF进行重写
2. 重写期间父进程将命令写到aof缓冲区和aof_rewrite缓冲区
3. 子进程重写完成后，父进程将重写缓冲区的数据写到新的aof文件
4. 使用新的aof文件替换老文件

# 持久化可能带来的问题

## fork

不管是RDB还是AOF，都需要fork子进程持久化，而fork需要复制父进程的空间内存页表，耗时与内存大小密切相关。

- 控制redis最大可用内存
- 合理配置Linux内存分配策略，避免fork时物理内存不足
- 避免不必要的全量复制

## 子进程开销

针对子进程的RDB AOF文件重写任务

- CPU密集操作，不要绑定单核CPU，不要跟其他CPU密集服务部署在仪器
- Linux有COW机制，父子进程共享物理内存页，父进程把需要修改的页创建副本，避免在大量写入时进行重写。
- 在AOF重写期间不做刷盘

## AOF刷盘阻塞

对于每秒刷盘的策略，redis使用子线程同步硬盘，如果硬盘资源繁忙，会造成主线程阻塞。

<img src="/imgs/1568723757563.png" alt="1568723757563" style="zoom: 33%;" />

- 如果同步慢，会阻塞主线程
- 最多丢失两秒数据