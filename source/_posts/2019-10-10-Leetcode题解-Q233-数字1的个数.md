---
title: Leetcode题解-Q233-数字1的个数
typora-root-url: ../../source/
date: 2019-10-10 20:19:19
mathjax: true
tags:
- leetcode
- 面试题
---

链接：<https://leetcode-cn.com/problems/number-of-digit-one/>

<!--more-->

# 数字1的个数

**华为现场面试遇到该题**

## 题目

给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。

示例:

> 输入: 13
> 输出: 6 
> 解释: 数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。

## 分析

两种思路

横向：遍历1~n，转换为字符串后统计1的个数，时间复杂度为
$$
O(n\times log_{10}(n))
$$
纵向：分别统计每一位出现1的次数，时间复杂度为
$$
O(log_{10}(n))
$$

## 数学法

考虑’1’ 在 个位，十位，百位，... 出现的情况，找规律

1. 个位：(n/10) + (n%10 != 0)
2. 十位：(n/100)*10 + min(max(n%100 - 10 + 1, 0), 10)
3. 百位：(n/1000)*100 + min(max(n%1000 - 100 + 1, 0), 100)

比如，n=161xy，计算百位上1的个数，

- 1- 16000，存在1600个
- 16001-161xy，存在1+xy个，即100~1xy，并且有xy<=99

所以 count(hundred of 16xyz) = 1600 + min(max(xyz-100 + 1, 0), 100)

其中max(xyz-100 + 1, 0 )是考虑到x可能为0.

最终有
$$
count(n) = (n/(i*10))*i + min(max((n \% (i*10)) -i+1,0),i),i\in {1,10,100...}
$$
每(i*10)个数，i位上的1出现i次。

```java
static class Solution {
    public int countDigitOne(int n) {
        int count = 0;
        for (long i = 1; i <= n; i *= 10) {
            long divider = i * 10;
            count += (n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);
        }
        return count;
    }
}
```

