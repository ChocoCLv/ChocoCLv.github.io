---
title: 蘑菇街直播部门面试拾遗
typora-root-url: ../../source/
date: 2019-09-16 00:27:19
tags:

---

# 蘑菇街一面记录

## 不同序列化方式对比

序列化实际上就是将内存中的数据以一定格式表达出来，序列化后的数据可以存储在本地也可以在网络上传输。对于Java对象而言，序列化的内容可能会包括类的继承关系。

序列化可以分为文本和二进制两种形式。

其中Json/XML为文本格式，比如Spring中从xml加载bean的定义并实例化实际上就是一个使用xml反序列化的过程。文本格式的序列化可读性好，但是性能差。一般应用于前后端交互接口。

对于RPC框架而言，需要追求极致性能，一般会考虑使用二进制序列化。二进制序列化往往会对数据进行压缩，使用尽可能小的数据量表达更多的信息。

|                    | 优点                                     | 缺点                                                         |
| ------------------ | ---------------------------------------- | ------------------------------------------------------------ |
| hessian            | 默认支持跨语言                           | 较慢                                                         |
| Protostuff         | 速度快，基于protobuf                     | 需静态编译                                                   |
| Protostuff-Runtime | 无需静态编译，但序列化前需预先传入schema | 不支持无默认构造函数的类，反序列化时需用户自己初始化序列化后的对象，其只负责将该对象进行赋值 |
| Java               | 使用方便，可序列化所有类                 | 速度慢，占空间                                               |
| Kryo               | 速度快，序列化后体积小                   | 跨语言支持较复杂                                             |

> hsf/dubbo默认使用的hessian2改造后的hessian lite。

### 不同序列化生成的字节码大小

![1568616201479](/imgs/1568616201479.png)

### 平均响应时间

![1568616256447](/imgs/1568616256447.png)

### tps

![1568616306911](/imgs/1568616306911.png)

## netty的线程模型，如何拆包

netty使用了Reactor主从多线程模型。

https://www.jianshu.com/p/128ddc36e713

netty提供了多种拆包方式，当然也可以用户自定义协议。

- DelimiterBasedFrameDecoder是基于消息边界方式进行粘包拆包处理的。
- FixedLengthFrameDecoder是基于固定长度消息进行粘包拆包处理的。
- LengthFieldBasedFrameDecoder是基于消息头指定消息长度进行粘包拆包处理的。
- LineBasedFrameDecoder是基于行来进行消息粘包拆包处理的。

## 代理的实现方式，以及对比

静态代理 动态代理

| 动态代理 | 特点                                                         |
| -------- | ------------------------------------------------------------ |
| jdk      | 被代理对象必须要实现接口，实际上是对接口的代理               |
| cglib    | 是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口。底层使用ASM字节码框架实现。 |
| asm      | 低级的字节码生成工具，还可以用于热部署、性能诊断和mock，参考https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html |

性能上asm>cglib>jdk

在1.6和1.7的时候，JDK动态代理的速度要比CGLib动态代理的速度要慢，但是并没有教科书上的10倍差距，在JDK1.8的时候，JDK动态代理的速度已经比CGLib动态代理的速度快很多了

## 线程池参数设置问题

如何设置合适的值，io密集，cpu密集

### 线程池参数

| 参数                     | 含义                       | 注意                                     |
| ------------------------ | -------------------------- | ---------------------------------------- |
| corePoolSize             | 核心线程数                 |                                          |
| maxPoolSize              | 最大线程数                 |                                          |
| keepAliveTime            | 核心线程池外线程的存活时间 | 核心线程默认不会被回收，但是可以显式指定 |
| rejectedExecutionHandler | 拒绝策略，                 | 当线程池满并且任务队列满时拒绝           |
| threadFactory            | 线程工厂                   |                                          |
| workQueue                | 任务队列                   | 注意设置队列长度                         |

### 如何设置

参数的设置跟系统的负载有直接的关系，下面为系统负载的相关参数：

- tasks，每秒需要处理的最大任务数量
- tasktime，处理第个任务所需要的时间
- responsetime，系统允许任务最大的响应时间，比如每个任务的响应时间不得超过2秒。

#### corePoolSize:

每个任务需要tasktime秒处理，则每个线程每钞可处理1/tasktime个任务。系统每秒有tasks个任务需要处理，则需要的线程数为：tasks/(1/tasktime)，即tasks*tasktime个线程数。假设系统每秒任务数为100~1000，每个任务耗时0.1秒，则需要100*0.1至1000*0.1，即10~100个线程。那么corePoolSize应该设置为大于10，具体数字最好根据8020原则，即80%情况下系统每秒任务数，若系统80%的情况下第秒任务数小于200，最多时为1000，则corePoolSize可设置为20。

#### queueCapacity:

任务队列的长度要根据核心线程数，以及系统对任务响应时间的要求有关。队列长度可以设置为(corePoolSize/tasktime)*responsetime： (20/0.1)*2=400，即队列长度可设置为400。

#### maxPoolSize:

当系统负载达到最大值时，核心线程数已无法按时处理完所有任务，这时就需要增加线程。每秒200个任务需要20个线程，那么当每秒达到1000个任务时，则需要(1000-queueCapacity)*(20/200)，即60个线程，可将maxPoolSize设置为60。

#### cpu密集 io密集

CPU密集型任务应配置尽可能小的线程，如配置CPU个数+1的线程数，IO密集型任务应配置尽可能多的线程，因为IO操作不占用CPU，不要让CPU闲下来，应加大线程数量，如配置两倍CPU个数+1，而对于混合型的任务，如果可以拆分，拆分成IO密集型和CPU密集型分别处理，前提是两者运行的时间是差不多的，如果处理时间相差很大，则没必要拆分了。

## 任务调度引擎vs消息队列

为什么要使用任务调度引擎，而不是直接使用消息队列。

## mybatis

### 调用mybatis接口时发生了什么

> 1. Mapper 接口在初始SqlSessionFactory 注册的。
>
> 2. Mapper 接口注册在了名为 MapperRegistry 类的 HashMap中， key = Mapper class value = 创建当前Mapper的工厂。
>
> 3. Mapper 注册之后，可以从SqlSession中get
>
> 4. SqlSession.getMapper 运用了 JDK动态代理，产生了目标Mapper接口的代理对象。
>
> 5. 动态代理的 代理类是 MapperProxy ，这里边最终完成了增删改查方法的调用。
>
>    https://www.cnblogs.com/demingblog/p/9544774.html

### 无spring使用mybatis

1. 使用xml配置文件创建SqlSessionFactory
2. 从SqlSessionFactory中获取session
3. 从session中获取mapper，传入mapper.class
4. 调用mapper接口的方法

### spring如何加载mybatis

- 构建SqlSessionFactory，实现InitializingBean接口，在afterPropertiesSet中buildSqlSessionFactory。
- 把Mappers注入到Spring容器管理

## tomcat reload时classloader干了啥

使用新的classloader加载后旧的类没有关联的实例对象后将被回收（不是马上）。

tomcat的reloadable属性实际上是配置热部署，即检测到WEB-INF/classes和WEB-INF/lib目录下class文件有改动后会重新加载。

### 自定义classloader

Java使用classloader+类全限定名来唯一确定一个类，一种热部署方案是使用新的classloader加载修改后的class文件，这样加载后将使用新的类创建实例。但是在实际应用中很多类对象都是单例的，这种机制无法工作。tomcat的热部署也不是使用这种方案。

### java.lang.instrument

Tomcat中的class文件是通过org.apache.catalina.loader. WebappClassLoader装载的。

在热部署的情况下，对于被该classloader 加载的class文件，它的classloader始终是同一个WebappClassLoader，除非容器重启了，相信做完这个实验你就不会再认为tomcat是使用一个新的classloader来加载修改过的class了，而且对于有状态的实例，之前该实例拥有的属性和状态都将保存，并在下次执行时拥有了新的class的逻辑，这就是热部署的神秘之处（其实每个实例只是保存了该实例的状态属性，我们通过序列化对象就能看到对象中包含的状态，最终的逻辑还是存在于class文件中）。

class重定义是通过：java.lang.instrument实现的，具体可参考相关文档。

