---
title: 关于hashmap的那点事儿
typora-root-url: ../../source/
date: 2019-09-18 21:37:40
tags:
- HashMap
- ConcurrentHashMap
- Java
---

jdk1.8中的HashMap和ConcurrentHashMap

<!--more-->

# HashMap

## hash算法

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

即将Object.hashCode()的前16位异或后16位。这里有个对key的判空，所以HashMap可以接受Key为null。

## 扩容算法

### 何时扩容

在put之前，判断当前Map中的键值对数量是否超过阈值。初始阈值为桶大小（2的幂），之后扩容的阈值为

```java
if (oldCap > 0) {
    if (oldCap >= MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return oldTab;
    }
    else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
    oldCap >= DEFAULT_INITIAL_CAPACITY)
    	newThr = oldThr << 1; // double threshold
}
else if (oldThr > 0) // initial capacity was placed in threshold
	newCap = oldThr;
else {               // zero initial threshold signifies using defaults
    newCap = DEFAULT_INITIAL_CAPACITY;
    newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
}
if (newThr == 0) {
    float ft = (float)newCap * loadFactor;
    newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
    (int)ft : Integer.MAX_VALUE);
}
```

### 怎么扩容

```java
Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
table = newTab;
if (oldTab != null) {
    for (int j = 0; j < oldCap; ++j) {
        Node<K,V> e;
        if ((e = oldTab[j]) != null) {
            oldTab[j] = null;
            if (e.next == null)
                newTab[e.hash & (newCap - 1)] = e;//这里体现了cap为2的幂的作用，用位运算加速取模
            else if (e instanceof TreeNode)
                ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
            else { // preserve order //区别于1.7，这里会保留原来的链表顺序，避免出现环
                Node<K,V> loHead = null, loTail = null;
                Node<K,V> hiHead = null, hiTail = null;
                Node<K,V> next;
                do {
                    next = e.next;
                    //位置不变
                    if ((e.hash & oldCap) == 0) {
                        if (loTail == null)
                            loHead = e;
                        else
                            loTail.next = e;
                        loTail = e;
                    }
                    //移动到扩容后新的位置
                    else {
                        if (hiTail == null)
                            hiHead = e;
                        else
                            hiTail.next = e;
                        hiTail = e;
                    }
                } while ((e = next) != null);
                //将rehash后的链表头放到新桶里
                if (loTail != null) {
                    loTail.next = null;
                    newTab[j] = loHead;
                }
                if (hiTail != null) {
                    hiTail.next = null;
                    newTab[j + oldCap] = hiHead;
                }
            }
        }
    }
}
```

# ConcurrentHashMap

## put

使用sychronized对一个桶进行加锁（区别于jdk1.7的segment锁），put成功后使用cas修改数量

## get

读操作不需要加锁，使用了volatile修饰val和next，保证了可见性，避免读到脏数据。

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    volatile V val;
    volatile Node<K,V> next;
	...
}
```

### 扩容

//TODO